<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js & Express Route Building Guide</title>

    <link 
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" 
      rel="stylesheet" 
    />

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                Helvetica, Arial, sans-serif;
            line-height: 1.6;
            /* Use a dark background to match the code theme */
            background-color: #2b2b2b;
            color: #f1f1f1;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
        }
        h1, h2, h3 {
            border-bottom: 2px solid #555;
            padding-bottom: 5px;
            color: #fff;
        }
        h1 {
            font-size: 2em;
        }
        h2 {
            font-size: 1.6em;
            margin-top: 1.5em;
        }
        h3 {
            font-size: 1.3em;
            margin-top: 1.2em;
        }
        
        /* * This targets the <pre> blocks generated by Prism
         * We remove the default dark background since the body is already dark.
         * You can customize this!
        */
        pre[class*="language-"] {
            background: #272822; /* This is from the Okaidia theme */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #444;
        }

        /* Inline code */
        :not(pre) > code {
            background-color: #444;
            padding: 2px 5px;
            border-radius: 3px;
            color: #e6db74; /* Yellowish, common in dark themes */
        }
        hr {
            border: 0;
            border-top: 2px solid #555;
            margin: 2em 0;
        }
        ul, ol {
            padding-left: 25px;
        }
        li {
            margin-bottom: 8px;
        }
        strong {
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>Node.js & Express Route Building Guide</h1>
    <p>
        Here's a guide and checklist for building a complete, modular route in
        Node.js and Express.
    </p>
    <p>
        This guide assumes you have a basic Node.js project set up
        (<code>npm init -y</code>) and have installed Express
        (<code>npm install express</code>).
    </p>

    <h2>üìÇ The Modular File Structure</h2>
    <p>
        First, let's set up the recommended file structure. This separates your
        concerns, making your app <em>much</em> easier to manage.
    </p>

    <pre><code class="language-bash">/my-project
|
|-- üìÇ node_modules/
|-- üìÇ controllers/
|   |-- userController.js    # The "brain" - logic for user routes
|
|-- üìÇ middleware/
|   |-- authMiddleware.js    # The "gatekeeper" - protects routes
|
|-- üìÇ routes/
|   |-- userRoutes.js        # The "traffic cop" - defines user URL paths
|
|-- üìÇ views/
|   |-- dashboard.html       # The HTML file we want to send
|
|-- server.js                # The "entry point" - starts the app
|-- package.json</code></pre>

    <hr />

    <h2>üìù The Step-by-Step Build Checklist</h2>
    <p>
        Follow these steps in order. We'll build a single route:
        <strong><code>GET /users/dashboard</code></strong> which is protected
        by auth and sends an HTML page.
    </p>

    <h3>&#9744; Step 1: The Main Server (<code>server.js</code>)</h3>
    <p>
        This file starts your server and tells Express where to find your
        route files. It's the "entry point."
    </p>
    
    <pre><code class="language-javascript">// server.js
const express = require('express');
const app = express();
const PORT = 3000;

// Import your route file
const userRoutes = require('./routes/userRoutes');

// --- Global Middleware ---
app.use(express.json()); // Allows your server to accept JSON data
app.use(express.static('public')); // (Optional) For serving static files like CSS

// --- Use Your Routes ---
// Tell Express to use 'userRoutes' for any URL
// that starts with '/users'
app.use('/users', userRoutes);

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});</code></pre>

    <h3>&#9744; Step 2: The Route File (<code>routes/userRoutes.js</code>)</h3>
    <p>
        This file defines the <strong>path</strong> (<code>/dashboard</code>),
        the <strong>method</strong> (<code>GET</code>), and connects the
        <strong>middleware</strong> and <strong>controller</strong> to it.
    </p>
    
    <pre><code class="language-javascript">// routes/userRoutes.js
const express = require('express');
const router = express.Router(); // Get the Express router

// Import the "logic" (controller)
const userController = require('../controllers/userController');

// Import the "gatekeeper" (middleware)
const authMiddleware = require('../middleware/authMiddleware');

// --- Define Your Routes ---

// Path: GET /users/dashboard
// This route is "protected".
// 1. A request comes in for 'GET /users/dashboard'.
// 2. Express runs 'authMiddleware.checkAuth' first.
// 3. If the middleware calls next(), Express runs 'userController.getDashboardPage'.
router.get(
  '/dashboard',
  authMiddleware.checkAuth,
  userController.getDashboardPage
);

// You could add other routes here...
// router.post('/login', userController.loginUser);

module.exports = router; // Export the router for server.js to use</code></pre>

    <h3>
        &#9744; Step 3: The Middleware (<code>middleware/authMiddleware.js</code>)
    </h3>
    <p>
        This is your "gatekeeper." It runs <em>before</em> the controller. Its
        job is to check if the user is allowed to proceed.
    </p>
    <p>It <strong>must</strong> do one of two things:</p>
    <ol>
        <li>
            Call <strong><code>next()</code></strong> to allow the request to
            continue to the controller.
        </li>
        <li>
            Send a <strong>failure response</strong> (and <em>don't</em> call
            <code>next()</code>).
        </li>
    </ol>
    
    <pre><code class="language-javascript">// middleware/authMiddleware.js

exports.checkAuth = (req, res, next) => {
  // This is a basic example. A real app might check
  // a JWT token (req.headers.authorization) or a session.
  const isUserAuthenticated = req.session && req.session.user; // (Needs express-session)

  if (isUserAuthenticated) {
    // --- Success ---
    // User is authenticated! Proceed to the next step (the controller).
    console.log('Auth success');
    next();
  } else {
    // --- Failure ---
    // User is not authenticated. Send an error response and STOP.
    console.log('Auth failed');
    return res.status(401).json({
      success: false,
      message: 'Access denied. Please log in.',
    });
  }
};</code></pre>

    <h3>
        &#9744; Step 4: The Controller (<code>controllers/userController.js</code>)
    </h3>
    <p>
        This is the "brain." It only runs if the middleware called
        <code>next()</code>. Its job is to do the main logic and send the final
        response.
    </p>
    
    <pre><code class="language-javascript">// controllers/userController.js
const path = require('path'); // Node.js 'path' module

exports.getDashboardPage = (req, res) => {
  // The user is authenticated (middleware passed).
  // Now, we build and send the final response.

  try {
    // --- Success Response (Sending HTML) ---

    // We build the full file path to our HTML file.
    // __dirname means "the current directory" (which is /controllers)
    // '../views/dashboard.html' goes "up one level" and into /views
    const htmlFilePath = path.join(
      __dirname,
      '../views/dashboard.html'
    );

    // Send the file as the response
    res.sendFile(htmlFilePath);

    // Note: We don't need res.status(200) here,
    // as res.sendFile() handles it by default.
  } catch (error) {
    // --- Failure Response (Server Error) ---
    console.error('Error sending file:', error);

    // If something goes wrong (e.g., file doesn't exist)
    return res.status(500).json({
      success: false,
      message: 'Internal Server Error. Could not load dashboard.',
      error: error.message,
    });
  }
};</code></pre>

    <hr />

    <h2>üí° What About JSON Responses (APIs)?</h2>
    <p>
        You'll often send JSON data instead of HTML, especially for APIs. The
        concept is the same, but the controller response changes.
    </p>
    <p>
        Imagine you had a route <code>GET /users/data</code> to fetch user info.
        The controller would look like this:
    </p>
    
    <pre><code class="language-javascript">// controllers/userController.js

exports.getUserData = (req, res) => {
  try {
    // Logic: Find the user in a database...
    const userData = {
      id: 1,
      name: 'Jane Doe',
      email: 'jane@example.com',
    };

    if (!userData) {
      // --- Failure Response (404 Not Found) ---
      return res.status(404).json({
        success: false,
        message: 'User not found.',
      });
    }

    // --- Success Response (200 OK) ---
    return res.status(200).json({
      success: true,
      message: 'User data retrieved successfully.',
      data: userData, // This is the "payload"
    });
  } catch (error) {
    // --- Failure Response (500 Server Error) ---
    return res.status(500).json({
      success: false,
      message: 'An error occurred while fetching user data.',
    });
  }
};</code></pre>

    <p><strong>Key Takeaways for JSON Responses:</strong></p>
    <ul>
        <li>
            <strong>Status Code:</strong> Always set one
            (<code>.status(code)</code>).
            <ul>
                <li><code>200</code>: OK</li>
                <li><code>201</code>: Created (for <code>POST</code>)</li>
                <li><code>400</code>: Bad Request (user error)</li>
                <li><code>401</code>: Unauthorized (not logged in)</li>
                <li><code>404</code>: Not Found</li>
                <li><code>500</code>: Internal Server Error (your code broke)</li>
            </ul>
        </li>
        <li>
            <strong>Success Flag:</strong> <code>success: true</code> or
            <code>success: false</code>. This makes it <em>very</em> easy for
            the frontend to check if the request worked.
        </li>
        <li><strong>Message:</strong> A clear, human-readable message.</li>
        <li>
            <strong>Payload:</strong> The actual data (on success) or error
            details (on failure).
        </li>
    </ul>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

</body>
</html>